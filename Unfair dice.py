#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Feb 25 21:48:34 2020

@author: Ashley Shang
"""

import sys
import numpy as np 
import math
import matplotlib.pyplot as plt


# define heads = 1 and tails = 0
heads = 1
tails = 0


# assign a random value for the probability of seeing a "1" (p1), "2" (p2) or "3" (p3) for 
# the 3-sided unfair dice such that (p1, p2, p3) is uniformly distributed over the surface
# p1+p2+p3 = 1, where p1, p2, p3 are non-negative real numbers
def assign_probabilities_to_unfair_three_sided_dice() :
    # generate 3 random numbers from uniform [0,1]
    n1 = np.random.uniform()
    n2 = np.random.uniform()
    n3 = np.random.uniform()
    s = n1+n2+n3
    # standardize the numbers
    prob_of_one = n1/s
    prob_of_two = n2/s
    prob_of_three = n3/s
    return prob_of_one, prob_of_two, prob_of_three


# This function simulates a single toss of the unfair 3-sided dice
def toss_of_three_sided_unfair_dice(p1, p2, p3) :
    x = np.random.uniform()
    if (x < p1) :
        return 1
    elif (x < p2) :
        return 2
    else :
        return 3

# This function simulates a fair-coin using the unfair 3-sided dice
def simulate_fair_coin_from_unfair_three_sided_dice(p1, p2, p3) :
    x = []
    # toss 3 times and if every time we can get different result
    # the prob would be p1*p2*p3
    # and outcomes with this prob have 6 situations
    toss1 = toss_of_three_sided_unfair_dice(p1, p2, p3)
    toss2 = toss_of_three_sided_unfair_dice(p1, p2, p3)
    toss3 = toss_of_three_sided_unfair_dice(p1, p2, p3)
    
    x.extend([toss1, toss2, toss3])
    
    # if duplicates happens, re-toss
    while(len(x)!=len(set(x))):
        x = []
        toss1 = toss_of_three_sided_unfair_dice(p1, p2, p3)
        toss2 = toss_of_three_sided_unfair_dice(p1, p2, p3)
        toss3 = toss_of_three_sided_unfair_dice(p1, p2, p3)
        x.extend([toss1, toss2, toss3])
    
    # if 1 always occurs before 2, set heads. Otherwise, tails
    # There are multiple choice, we can also choose if 2 occurs before 3,
    # 1 occurs before 3, etc.
    if x.index(1) < x.index(2):
        return heads
    else:
        return tails

# get a U.I.I.D RV by making the unfair three sided dice into a fair coin... and tossing the 
# resulting fair-coin 32 times to get discrete RV that is uniformly distributed over the 
# integers in [0, 2^{32}-1]... dividing the resulting integer by 2^{32}-1 gives us (effectively)
# a U.I.I.D. RV
def get_uiid_rvs_by_tossing_the_unfair_three_sided_dice_32_times(p1, p2, p3) :
    result = 0
    for i in range(0, 32) :
        if (simulate_fair_coin_from_unfair_three_sided_dice(p1, p2, p3) == heads) :
            result = result | (1 << i)
        else :
            result = result | (0 << i)
    return float(result/(pow(2,32)-1))

# plotting the histogram of the continuous RV generated by tossing the unfair three sided dice
# sufficient number of times till we get 32 fair-coin-tosses, which are then converted into a 
# number in the unit-interval

# assigning probabilities to unfair three sided dice 
p1, p2, p3 = assign_probabilities_to_unfair_three_sided_dice()

if __name__ == '__main__':
    # read the number of trails
    no_of_trials = int(sys.argv[1])
    
    z = []
    for i in range(0, no_of_trials) :
        z.extend([get_uiid_rvs_by_tossing_the_unfair_three_sided_dice_32_times(p1, p2, p3)])
    
    plt.hist(z, bins=50)
    plt.ylabel('Histogram for ' + str(no_of_trials) + ' trials');
    plt.savefig("UIID_Histogram.pdf", bbox_inches='tight')

# converting (multiple) tosses of the unfair 3-sided Dice into a unit-normal distribution
# using the Box-Muller Method
    a = []
    for i in range(0,no_of_trials) :
        p = get_uiid_rvs_by_tossing_the_unfair_three_sided_dice_32_times(p1, p2, p3)
        q = get_uiid_rvs_by_tossing_the_unfair_three_sided_dice_32_times(p1, p2, p3)
        theta = 2*math.pi*p 
        r = np.sqrt(-2*math.log(q))
        a.extend([r*math.cos(theta)])
        a.extend([r*math.sin(theta)])
    plt.hist(a, bins=50)
    plt.ylabel('Histogram for ' + str(2*no_of_trials) + ' trials');
    plt.savefig("Unit_Normal_Histogram.pdf", bbox_inches='tight')
